import logging
import sqlite3
from typing import Annotated, Optional

from arcade.sdk import tool, ToolContext
from arcade_sql_customers.utils import get_database_connection

# Configure the logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@tool(requires_secrets=["CUSTOMER_DATABASE_PATH"])
def direct_query(
    context: ToolContext,
    query: Annotated[str, "The query to run in the database"]
) -> Annotated[dict, "The data returned from the database"]:
    """
    Query the data from the 'people' table with a query generated by the LLM.

    The database is a SQLite database with the following schema:

    CREATE TABLE people (
        id INTEGER PRIMARY KEY,
        Name TEXT,
        Age INTEGER,
        Location TEXT,
        Occupation TEXT,
        Email TEXT
    )

    Example row

    Name: William Hatfield
    Age: 39
    Location: Los Angeles, CA (IMPORTANT, use abbreviations for the state)
    Occupation: Adult guidance worker
    Email: ajohnson@hoover.net
    """
    logger.info("Starting query_customer_data function")
    logger.debug(f"Query received: {query}")

    # Get the database URL
    database_url = context.get_secret("CUSTOMER_DATABASE_PATH")
    if not database_url:
        logger.error("Database URL not found. Exiting function.")
        return {"results": []}

    # Connect to the database
    try:
        conn = get_database_connection(database_url)
    except sqlite3.Error as e:
        logger.error(f"Failed to connect to the database: {e}")
        return {"results": []}
    cursor = conn.cursor()

    try:
        # Execute the query
        cursor.execute(query)
        rows = cursor.fetchall()
        logger.info(f"Query executed successfully. Rows fetched: {len(rows)}")

        # Get column names
        column_names = [description[0] for description in cursor.description]
        logger.debug(f"Column names: {column_names}")

    except sqlite3.Error as e:
        # Handle any database errors
        logger.error(f"Database error during query execution: {e}")
        return {"results": []}
    else:
        # Prepare the results as a list of dictionaries
        results = [dict(zip(column_names, row)) for row in rows]
        logger.debug(f"Results prepared: {results}")
        return {"results": results}
    finally:
        # Ensure the database connection is closed
        conn.close()
        logger.info("Database connection closed.")


#@tool(requires_secrets=["CUSTOMER_DATABASE_PATH"])
def query_customer_data(
    context: ToolContext,
    columns_to_select: Annotated[
        Optional[list[str]],
        "List of columns to select from the 'people' table. If None, all columns are selected.",
    ] = None,
    filter_by_id: Annotated[Optional[int],
                            "Filter the results by ID."] = None,
    filter_by_age: Annotated[Optional[int],
                             "Filter the results by age."] = None,
    filter_by_name: Annotated[Optional[str],
                              "Filter the results by name."] = None,
    filter_by_location: Annotated[Optional[str],
                                  "Filter the results by location."] = None,
    order_by: Annotated[
        Optional[str], "Column to order the results by. Must be a valid column name."
    ] = None,
    limit: Annotated[int, "The maximum number of rows to return."] = 20,
) -> Annotated[dict, "The data returned from the database."]:
    """
    Query the data from the 'people' table with the provided parameters.

    The database is a SQLite database with the following schema:

    CREATE TABLE people (
        id INTEGER PRIMARY KEY,
        Name TEXT,
        Age INTEGER,
        Location TEXT,
        Occupation TEXT,
        Email TEXT
    )

    Example row

    Name: William Hatfield
    Age: 39
    Location: Los Angeles, CA (IMPORTANT, use abbreviations for the state)
    Occupation: Adult guidance worker
    Email: ajohnson@hoover.net
    """
    logger.info("Starting query_customer_data function")
    logger.debug(
        f"Parameters received: columns_to_select={columns_to_select}, "
        f"filter_by_id={filter_by_id}, filter_by_name={filter_by_name}, "
        f"filter_by_age={filter_by_age}, "
        f"filter_by_location={filter_by_location}, order_by={order_by}, "
        f"limit={limit}"
    )

    # Get the database URL
    print(context)
    database_url = context.get_secret("customer_database_path")
    if not database_url:
        logger.error("Database URL not found. Exiting function.")
        return {"results": []}

    # Connect to the database
    try:
        conn = get_database_connection(database_url)
    except sqlite3.Error as e:
        logger.error(f"Failed to connect to the database: {e}")
        return {"results": []}
    cursor = conn.cursor()

    # Define valid columns based on the schema
    valid_columns_list = ["id", "Name", "Age",
                          "Location", "Occupation", "Email"]

    try:
        # Determine columns to select
        if columns_to_select:
            # Validate column names
            invalid_columns = [
                col for col in columns_to_select if col not in valid_columns_list]
            if invalid_columns:
                logger.error(f"Invalid column names in columns_to_select:"
                             f" {invalid_columns}")
                return {"results": []}
            valid_columns = ", ".join(
                [f'"{col}"' for col in columns_to_select])
            logger.debug(f"Columns to select: {valid_columns}")
        else:
            valid_columns = "*"
            logger.debug("Selecting all columns.")

        # Build the base query
        query = f"SELECT {valid_columns} FROM people"
        params = []
        logger.debug(f"Initial query: {query}")

        # Build WHERE clause with filters
        where_clauses = []
        if filter_by_id is not None:
            where_clauses.append('"id" = ?')
            params.append(filter_by_id)
            logger.debug(f"Filtering by id: {filter_by_id}")
        if filter_by_age is not None:
            where_clauses.append('"Age" = ?')
            params.append(filter_by_age)
            logger.debug(f"Filtering by age: {filter_by_age}")
        if filter_by_name is not None:
            where_clauses.append('"Name" LIKE ?')
            params.append(f"%{filter_by_name}%")
            logger.debug(f"Filtering by Name: {filter_by_name}")
        if filter_by_location is not None:
            where_clauses.append('"Location" LIKE ?')
            params.append(f"%{filter_by_location}%")
            logger.debug(f"Filtering by Location: {filter_by_location}")
        if where_clauses:
            query += " WHERE " + " AND ".join(where_clauses)
            logger.debug(f"Added WHERE clauses: {' AND '.join(where_clauses)}")

        # Add ORDER BY clause if provided
        if order_by:
            if order_by not in valid_columns_list:
                logger.error(f"Invalid order_by column: {order_by}")
                return {"results": []}
            query += f' ORDER BY "{order_by}"'
            logger.debug(f"Ordering by: {order_by}")

        # Add LIMIT clause
        query += " LIMIT ?"
        params.append(limit)
        logger.debug(f"Limit set to: {limit}")

        logger.info(f"Executing query: {query}")
        logger.debug(f"With parameters: {params}")

        # Execute the query
        cursor.execute(query, params)
        rows = cursor.fetchall()
        logger.info(f"Query executed successfully. Rows fetched: {len(rows)}")

        # Get column names
        column_names = [description[0] for description in cursor.description]
        logger.debug(f"Column names: {column_names}")

    except sqlite3.Error as e:
        # Handle any database errors
        logger.error(f"Database error during query execution: {e}")
        return {"results": []}
    else:
        # Prepare the results as a list of dictionaries
        results = [dict(zip(column_names, row)) for row in rows]
        logger.debug(f"Results prepared: {results}")
        return {"results": results}
    finally:
        # Ensure the database connection is closed
        conn.close()
        logger.info("Database connection closed.")
